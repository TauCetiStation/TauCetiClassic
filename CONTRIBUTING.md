###Вклад (CONTRIBUTING)

* Some credits goes to [/tg/station](https://github.com/tgstation/-tg-station/blob/master/CONTRIBUTING.md)
* Также по ссылке рекомендую почитать и оригинал, здесь отражено многое, но не все.

####Вступление
Не буду тут расписывать длинную вступительную речь, а просто перейду к часто поднимаемым вопросам о том, как правильно внести свой вклад в проект (применимо вполне к любому другому, а не только к нам).

####Сообщения в чат
Для выведения сообщений в чат нужно использовать процедуру `to_chat(кому показать, "сообщение")`

Как не надо: `world << "Hello, World!"`

Как надо: `to_chat(world, "Hello, World!")`

####Все пути должны быть обязательно полными.
Как не надо:
```
obj
    var
        varname1 = 0
        varname2
    proc
        proc_name()
            code
    item
        weapon
            name = "Weapon"
            proc
                proc_name2()
                    ..()
                    code
```
Как надо:
```
/obj
    var/varname1 = 0
    var/varname2

/obj/proc/proc_name()
    code

/obj/item/weapon
    name = "Weapon"

/obj/item/weapon/proc/proc_name2()
    ..()
    code
```
Зачем спросите?
Самое важное в этом то, что плохой пример затрудняет весьма серьезно поиск по проекту. Если кто-то захочет найти `proc_name2()` и их будет в коде уже много, то результат будет выглядеть примерно так:
```
                proc_name2()
                proc_name2()
                proc_name2()
```
И дело не в том, что поиск показывает в каком файле находится этот прок (сторонний текстовой редактор), потому что их может быть много в одном файле и еще в других.

Во втором случае:
```
/obj/item/weapon/proc/proc_name2()
/obj/item/weapon/gun/proc_name2()
/obj/item/weapon/gun/pistol/proc_name2()
```

####Оператор ":"
Использование этого оператора крайне не приветствуется и причина проста — если удалить предмет который скажем имел переменную `varname20` и в коде где-то мы использовали `if(F:varname20 == 30)`, то при компиляции и запущенном сервере, мы даже не узнаем что этот отрезок кода больше не работает и не нужен, а хуже — если из-за этого перестанет что-то другое работать, но ошибок при этом не будет.
`F` к примеру был равен `/obj/item/fork` и мы удалили `/obj/item/fork` из кода. Выход будет примерно с использованием проверки на тип `istype(fork, /obj/item/fork)` с последующим прописыванием типа `var/obj/item/fork/F = fork` и "иф" уже будет выглядеть вот так `if(F.varname20 == 30)`.

####Пути должны начинаться с /
Как не надо:

`mob/living`

Как надо:

`/mob/living`

####Использование путей в виде текст формата
Как не надо:

`var/path = "/obj/item/someitem"`

Как надо:

`var/path = /obj/item/someitem`

В принципе все тоже что и с использованием оператора ":", если предмет или путь перестанет существовать в коде — шанс того что это заметят, может исчисляться в годах.

####Табы и пробелы.
Использование табов для отступа обязательно. Пробелы можно использовать для выравнивания чего-нибудь (чаще комментариев), но вначале надо сделать отступ настолько, насколько этого требует текущий блок кода.

####Копипаста:
Крайне не приветствуется. Речь идет о том, когда для вашего кода Вы сделали копипасту уже имеющегося чего-то в коде только потому, что вам было лень продумывать как внедрить ваш текущий код в уже имеющийся.

####Волшебные цифры и строки (Magic numbers)
Пример:
`if(stat == 2)` – в данном случае `2` попадает под эту категорию. Этих проверок может быть в коде тысяча, а если появилась необходимость `2` изменить на `3`? Выходит, что нужно будет потратить (возможно) несколько часов, чтобы изменить одну цифру! Ведь проверка может быть и не обязательно именно так поставлена, а хоть в тот же `switch()` и уже надо будет искать и это.
Поэтому в случае добавление нового кода пишем свой "дефайн", а в случае уже имеющихся - подставляем его:
```
#define DEAD 2
if(stat == DEAD)
    code
```
Теперь чтобы просто поставить статус `DEAD` на другую цифру, достаточно изменить одно число рядом с "дефайном"!
И конечно, все `#define` должны иметь нормальное название, чтобы всем было понятно, о чем идет речь в том или ином месте, потому что если `DEAD` будет назван как `D` или хуже того как `MERTV` - (не вздумайте так называть вообще что либо) то в будущем это может создать путаницу.

####Объявление аргументов в процедурах
Не должно быть конструкций типа `var/` и `as ...`

Как не надо:
```
/proc/foo(var/atom/A as area|turf|obj|mob)
```
Как надо:
```
/proc/foo(atom/A)
```

####Ранее использование return
Как не надо:
```
/datum/datum1/proc/proc1()
    if (thing1)
        if (!thing2)
            if (thing3 == 30)
                do stuff
```
Как надо:
```
/datum/datum1/proc/proc1()
    if (!thing1)
        return
    if (thing2)
        return
    if (thing3 != 30)
        return
    do stuff
```
####Операторы управления (if,while,for,etc)
(На одной строке)

Как не надо:
```
if (blah) return

switch(X)
    if(1) code
    if(2) code
```
Как надо:
```
if (blah)
    return

switch(X)
    if(1)
        code
    if(2)
        code
```
Все сравнения чего-либо с числом должны идти по такому формату `var` `operator` `number` и не в обратном виде: хорошо - `if (count <= 10)` плохо -  `if (10 >= count)`

####Модульность
Код должен быть модульным когда это возможно. Если идет добавление нового класса, желательно поместить его в отдельный файл. Но нужно понимать, когда это действительно надо, а когда лучше положить к уже имеющимся в правильное место.

####Операторы и пробелы
(Следование им больше приветствуется в угоду читабельности, но не обязанность)

* Операторы которые должны быть разделены пробелом
  * "bool" и логические операторы типа &&, || <, >, ==, и так далее (но не !)
  * Разделитель аргументов , (и ; когда использовано в цикле)
  * Оператор назначения = или += и прочие
* Операторы которые не надо разделять пробелом
  * Побитовые (bitwise) & или |
  * Операторы доступа такие как . и :
  * Скобки ()
  * логический !

Математические операторы +,-,/,* и так далее, как удобнее читать.

####Особенности ДМ
Циклы вида `for(var/i = 1, i <= some_value, i++)` достаточно распостраненный вид, но `for(var/i = 1 to some_value)` будет гораздо быстрее со стороны производительности. Стоит заметить, ключевое слово `to` приравнивается к меньше или равно  `<=`, поэтому если надо просто меньше `<` , тогда `1 to some_value-1`, ОДНАКО если `some_value` или `I` будет изменено по среди цикла под `for(...)` или если цикл выполняется с листом, то такой способ не может быть использован.

####Использование spawn() (применимо только к определенным проектам и прокам!! Которые настроили на такую работу, в противном случае рискуете усыпить работу целой системы!!)
При нехватке опыта, перестраховаться конечно стоит, однако лучше избегать использовать этот прок и понимать, когда надо а когда не надо. Например контроллер объектов `process()` и `life()` прок мобов может работать на `sleep()` и ничего не будет засыпать! Дело в том, что с использованием одной хитрости `sleep()` начинает работать также как `spawn()`, да еще и создавать меньшую нагрузку. Но не забивайте голову по началу, могу разве что совет дать на будущее посерфить интернеты про `spawn()/sleep()` и еще `set waitfor`, в доках бъенда скорее всего ничего не найдете, т.к это недокументированная особенность.

####Пулл Реквесты (ПР)
Как и в большинстве других проектов, никто не скажет когда такой-то ПР будет замержен в проект. Как минимум он должен пройти проверку на очевидные детали, а в случае если это еще и какое-нибудь нововведение, то еще обсуждение.

Добавляя что-то новое, быть готовым к тому, что если возникнут проблемы, то решать скорее всего их Вам.

#####А чтобы не убить как минимум себе нервы стоит соблюсти вот эти маленькие советы:
САМОЕ ВАЖНОЕ!! Пулл реквест должен содержать только те изменения, которые Вы внесли собственноручно. Чтобы случайно не закинуть лишний файл или изменения которые могли появиться даже сами по себе (в случае если у вас что-то не настроено) придумали две стадии пред просмотра в клиенте/терминале и уже в процессе создания самого ПР.

Название коммита (хотябы начального) не менее важно чем название Пулл Реквеста (оставьте шуточные названия и описания для каких-то конкретных событий, а во все остальное время, подходите к вопросу чуть более серьезно). А еще желательно внятное описание того, что добавлено.

ПР должен содержать как правило только одно нововведение или вещи, которые имеют отношение друг к другу. Не надо делать такой ПР, в котором у вас добавлен классный автомат, новый моб, обновление хирургии. В случае если ПР направлен только на исправление ошибок, тогда «мешанина» допускается. Но все же, читать изменения проще, когда перед глазами что-то конкретное, а не мешанина из кучи «фич», «багфиксов» и прочего.

#####А еще
После того, как ваше нововведение было добавлено в проект, любой может вносить изменения и работать с кодом, но права на одобрение частично остаются за вами. В случае если много людей недовольны, тогда лучше отступить и согласиться с изменениями.
Но не стоит забывать, решение того что будет добавлено а что нет остается за командой проекта или лицами которые отвечают за контент. Иначе говоря, кодить можно все что душе угодно, но не все может пройти в проект. Лучше согласовать с людьми и/или с теми, кто отвечает за контент вносимый в проект.


Вот наверно самый минимум того, что стоит знать.
